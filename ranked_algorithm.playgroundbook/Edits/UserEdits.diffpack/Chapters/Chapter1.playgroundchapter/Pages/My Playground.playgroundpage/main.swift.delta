<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Diff</key>
	<array>
		<dict>
			<key>ModifiedContent</key>
			<string>public class VoteCount {
    private var votes: [String: [String]]
    private var votesHistory: [[String: [String]]] = []
    private var round: Int = 0
    private var filledVotes: Int = 0
    private var emptyVotes: Int = 0
    private var totalVotes: Int = 0
    private var done: Bool = false
    private var majorityFound: Bool = false
    private var winner = String()
    
    public init(votes: [String: [String]]) {
        self.votes = votes
        votesHistory.append(votes)
    } 
    
    func count() {
        var firstChoice = [String]()
        var loser = String()
        
        while !done {
            
            for (voter, votes) in votes {
                firstChoice.append(votes[0])
            }
            
            if let lastOption = findLoser(for: firstChoice) {
                loser = lastOption
            }  
            
            round += 1
            removeOption(from: votes, remove: loser)
            winnerFound(for: firstChoice)
            
            print(winner)
        } 
        
        print(votes)
    } 
    
    private func findLoser(for votes: [String]) -&gt; String? {
        var numberOfVotes = votes.count
        
        let scores = votes.histogram
        
        let wrappedMaxScore = scores.min { a, b in a.value &lt; b.value}
        
        var loser = String()
        
        if let (key, value) = wrappedMaxScore {
            return key
        } else {
            return nil
        }
    } 
    
    func removeOption(from votes: [String: [String]], remove option: String) { 
        for (voter, options) in votes {
            self.votes["\(voter)"] = options.filter(){$0 != option}
        } 
    }
    
    private func winnerFound (for votes: [String]) -&gt; Bool {
        var numberOfVotes = votes.count
        
        let scores = votes.histogram
        
        let wrappedMaxScore = scores.max { a, b in a.value &lt; b.value}
        
        var leader = String()
        var score = Int()
        
        if let (key, value) = wrappedMaxScore {
            leader = key
            score = value
        }
        
        //TODO: this check is a mess and a half
        
        if score &gt; numberOfVotes/2 {
            winner = leader
            majorityFound = true
            done = true
            return true
        } else  if score == numberOfVotes/2 {
            done = true
            winner = leader
            return true
        } else {
            return false
        }
    }
}

struct Result {
    public let totalVoters: Int
    public let majorityFound: Bool
    public let winner: String?
}

struct Vote {
    let creator: String
    var votes: [Int]
    // TODO: add a date variable
}

extension Sequence where Element: Hashable {
    var histogram: [Element: Int] {
        return self.reduce(into: [:]) {counts, elem in counts[elem, default: 0] += 1}
    }
}

let votes: [String: [String]] = [
"1": ["C", "B", "A", "D"],
"2": ["D", "B", "A", "C"],
"3": ["A", "C", "D", "B"],
"4": ["A", "B", "D", "C"],
"5": ["D", "A", "C", "B"]
]

VoteCount(votes: votes).count()
</string>
			<key>ModifiedRange</key>
			<string>{1, 3090}</string>
			<key>OriginalContent</key>
			<string></string>
			<key>OriginalRange</key>
			<string>{1, 0}</string>
		</dict>
	</array>
	<key>File</key>
	<string>Chapters/Chapter1.playgroundchapter/Pages/My Playground.playgroundpage/main.swift</string>
</dict>
</plist>
